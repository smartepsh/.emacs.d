#+title: 知识库配置文件
#+STARTUP: overview

* 移除 org-mode
移除 emacs 自带 org 。
#+begin_src emacs-lisp
  (assq-delete-all 'org package--builtins)
  (assq-delete-all 'org package--builtin-versions)
#+end_src

* 本体
#+begin_src emacs-lisp
  (use-package org
    :pin gnu
    :ensure nil
    ;; :ensure-system-package terminal-notifier
    :defer t
    :init
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (applescript . t)
       (elixir . t)
       (org . t)
       (haskell . t)
       (lisp . t)
       (plantuml . t)
       (mermaid . t)
       (racket . t)))
    ;;(R . t)))
    :config
      ;;; auto display inline images on Org TAB cycle expand headlines.
    ;; (add-hook 'org-mode-hook 'scimax-src-keymap-mode)
    (add-hook 'org-cycle-hook #'org-display-subtree-inline-images)
    (add-to-list 'org-export-backends 'md)
    (setq org-todo-keywords '((sequence "TODO(t/!)" "DOING(i/!)" "|" "DONE(d/!)" "CANCELED(c@)"))
          ;; org-default-notes-file org-agenda-file
          org-archive-location (concat org-directory "Archived/" "%s_archive::")
          org-id-locations-file (concat org-directory ".org-id-locations")
          org-plantuml-jar-path (concat private/config-directory "plantuml-1.2021.16.jar")
          org-log-done nil
          ;; (nconc org-modules '(org-id))
          ;; org-refile-targets '((org-agenda-files :maxlevel . 2))
          org-refile-use-outline-path 'file
          org-outline-path-complete-in-steps nil
          org-refile-allow-creating-parent-nodes 'confirm
          org-refile-use-cache t
          org-startup-truncated nil
          org-confirm-babel-evaluate nil
          org-use-sub-superscripts  '{}
          org-M-RET-may-split-line '((headline . nil) (item . nil) (default . t))
          org-html-validation-link nil)
    ;; refresh cache when emacs idle 5 mins
    (run-with-idle-timer 300 t (lambda ()
                                 (org-refile-cache-clear)
                                 ;; (org-refile-get-targets)
                                 (org-roam-db-sync))))
#+end_src

* 路径管理

真实路径在 icloud 中。借由 icloud 实现云同步。
#+begin_src emacs-lisp
    (setq base-directory  (file-truename "~/KentonBase/")
          private/book-directory (concat base-directory "publications/")
          org-directory (concat base-directory "notes/")
          old-org-directory (concat base-directory "old-archives/"))
#+end_src

为老的记录做个存档，进入该文件夹后依然可以进行搜索。
#+begin_src emacs-lisp :tangle "/Users/smartepsh/KentonBase/old-archives/.dir-locals.el"
  ((nil . (
           (org-roam-directory . "/Users/smartepsh/Library/Mobile Documents/com~apple~CloudDocs/KentonBase/old-archives/")
           (org-roam-db-location . "/Users/smartepsh/Library/Mobile Documents/com~apple~CloudDocs/KentonBase/old-archives/org-roam.db"))))
#+end_src
* 书籍管理 (calibredb)
#+begin_src emacs-lisp :tangle no
  (use-package calibredb
    :defer t
    :quelpa (calibredb :fetcher github :repo "chenyanming/calibredb.el" :branch "develop")
    :commands (calibredb)
    :config
    (setq calibredb-size-show t
          ;;calibredb-format-all-the-icons t
          calibredb-id-width 4
          calibredb-title-width 40
          calibredb-date-width 0
          calibredb-root-dir private/book-directory
          calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir)
          calibredb-library-alist '(private/book-directory))
    :general
    (local-leader
      :keymaps 'calibredb-show-mode-map
      "?" 'calibredb-entry-dispatch
      "o" 'calibredb-find-file
      "O" 'calibredb-find-file-other-frame
      "V" 'calibredb-open-file-with-default-tool
      "s" 'calibredb-set-metadata-dispatch
      "e" 'calibredb-export-dispatch
      "q" 'calibredb-entry-quit
      "y" 'calibredb-yank-dispatch
      "," 'calibredb-quick-look
      "." 'calibredb-open-dired
      "\M-/" 'calibredb-rga
      "\M-t" 'calibredb-set-metadata--tags
      "\M-a" 'calibredb-set-metadata--author_sort
      "\M-A" 'calibredb-set-metadata--authors
      "\M-T" 'calibredb-set-metadata--title
      "\M-c" 'calibredb-set-metadata--comments)
    (local-leader
      :keymaps 'calibredb-search-mode-map
      "<RET>" 'calibredb-find-file
      "?" 'calibredb-dispatch
      "a" 'calibredb-add
      "A" 'calibredb-add-dir
      "c" 'calibredb-clone
      "d" 'calibredb-remove
      "D" 'calibredb-remove-marked-items
      "j" 'calibredb-next-entry
      "k" 'calibredb-previous-entry
      "l" 'calibredb-virtual-library-list
      "L" 'calibredb-library-list
      "n" 'calibredb-virtual-library-next
      "N" 'calibredb-library-next
      "p" 'calibredb-virtual-library-previous
      "P" 'calibredb-library-previous
      "s" 'calibredb-set-metadata-dispatch
      "S" 'calibredb-switch-library
      "o" 'calibredb-find-file
      "O" 'calibredb-find-file-other-frame
      "v" 'calibredb-view
      "V" 'calibredb-open-file-with-default-tool
      "," 'calibredb-quick-look
      "." 'calibredb-open-dired
      "y" 'calibredb-yank-dispatch
      "b" 'calibredb-catalog-bib-dispatch
      "e" 'calibredb-export-dispatch
      "r" 'calibredb-search-refresh-and-clear-filter
      "R" 'calibredb-search-clear-filter
      "q" 'calibredb-search-quit
      "m" 'calibredb-mark-and-forward
      "f" 'calibredb-toggle-favorite-at-point
      "x" 'calibredb-toggle-archive-at-point
      "h" 'calibredb-toggle-highlight-at-point
      "u" 'calibredb-unmark-and-forward
      "i" 'calibredb-edit-annotation
      "<DEL>" 'calibredb-unmark-and-backward
      "<backtab>" 'calibredb-toggle-view
      "TAB" 'calibredb-toggle-view-at-point
      "\M-n" 'calibredb-show-next-entry
      "\M-p" 'calibredb-show-previous-entry
      "/" 'calibredb-search-live-filter
      "\M-t" 'calibredb-set-metadata--tags
      "\M-a" 'calibredb-set-metadata--author_sort
      "\M-A" 'calibredb-set-metadata--authors
      "\M-T" 'calibredb-set-metadata--title
      "\M-c" 'calibredb-set-metadata--comments))
#+end_src

* Org Mode

** Ebook Reader
org-mode 用来干嘛呢？对吧？
*** epub
#+begin_src emacs-lisp
  (use-package nov
    :mode ("\\.epub\\'" . nov-mode)
    :init
    (setq nov-save-place-file (concat org-directory "nov-places"))
    :config
    (clear-spc
      :keymaps 'nov-mode-map))

  (use-package nov-xwidget
    :quelpa (nov-xwidget :fetcher github :repo "chenyanming/nov-xwidget" :branch "main")
    :after nov
    :config
    (add-hook 'nov-mode-hook 'nov-xwidget-inject-all-files))
#+end_src
*** TODO skim with org-roam
设置更加具有交互性的 skim 行为。探索中。。。想法 [[https://emacs-china.org/t/org-ref-integration-with-skim-app-update/4614/14][源自于此]] ，但这里的代码并不能成功运行，而且他是利用 skim 笔记在页面中的索引做导航的，所以干脆改为根据 note id 做导航吧。


**** 资料数据库 Zotero
在家庭网络环境中，有一台 calibredb 服务器保存了全量的发行物。但众所周知，本人一贯是“买过即看过”的忠实拥护者，所以里面的书籍，绝大多数都是只看了封面，那必然不配“污染”我的笔记环境。
所以，我们会利用 Zotero 在本机来整理我们“阅读中”的资料。

除发行物、论文外，Zotero 还可以抓取网页快照，非常适合资料的收集。并统一由 BetterBibtex 插件进行 bibtex 文件的导出，该 bibtex 文件会作为我们的 =资料数据库= 使用。

**** 为 pdf 设置 citekey

打开 pdf 有以下几个途径：
1. 在 emacs 中通过 =citar-open= 方法选中对应的 pdf ，会通过 skim 打开；
2. 在 Zotero 选中 entry 使用 skim 打开；
3. 直接在 skim 中打开文件。

可以看出，pdf 文件的入口均为 =skim= 。

所以，我们在 alfred 中设置 workflow 来实现 =为 pdf 设置 citekey= 的功能。

主要思路：
1. 在 skim 中获取文件路径
2. 通过程序根据文件路径在 bibtex 文件中查找对应的 entry , 拿到 citekey
3. 通过 Applescript 在 skim 中为 pdf 首页添加含有 citekey 的 note 记录。

**** 创建 fleeting note

针对 bibtex 中的每一个 entry ，我们都会创建一个对应的总笔记，用于集中与之相关的散笔记，和 fleeting 笔记，以供后续整理。

我们最终采用 =org-protocol= 与 =org-roam-capture= 配合生成 note 。

可以通过 emacsclient 打开 ="org-protocol://skimnote?nodeid={nodeid}&noteid={noteid}&ref={citekey}&body={quote}"= 该链接，会自动创建笔记

***** capture 模板
此处无法使用 file+olp target ，可能是个 bug ，参考[[https://github.com/org-roam/org-roam/issues/2199][该 issue]] 。

#+begin_src emacs-lisp :tangle no
  ;; 该值在后续代码中有设置，此处无需 tangle
  (setq org-roam-capture-templates
        '(("q" "fleeting skim note" entry "* TODO ${noteid}\n:PROPERTIES:\n:ID: ${nodeid}\n:ROAM_REFS: ${ref}\n:SKIM_NOTE_ID: ${noteid}\n:END:\n#+begin_quote\n${body}\n#+end_quote\n%?"
           :target
           ;;(file+olp "ref/${ref}.org" ("Fleeting"))
           (file "ref/${ref}.org")
           :unnarrowed t
           :immediate-finish t
           :jump-to-captured t
           :prepend t)
          ("s" "fleeting skim note without quote" entry "* TODO ${noteid}\n:PROPERTIES:\n:ID: ${nodeid}\n:ROAM_REFS: ${ref}\n:SKIM_NOTE_ID: ${noteid}\n:END:\n%?"
           :target
           ;;(file+olp "ref/${ref}.org" ("Fleeting"))
           (file "ref/${ref}.org")
           :unnarrowed t
           :immediate-finish t
           :jump-to-captured t
           :prepend t)
          ))
#+end_src
***** protocol 配置
#+begin_src emacs-lisp
  (defun skim-note-handler (data)
    (let ((body (plist-get data :body)))
      (if body
          (org-roam-capture-
           :keys "q"
           :node (org-roam-node-create :id (plist-get data :nodeid))
           :info (list :ref (plist-get data :ref)
                       :body (plist-get data :body)
                       :link (plist-get data :link)
                       :noteid (plist-get data :noteid)
                       :nodeid (plist-get data :nodeid))
           :templates org-roam-capture-templates)
        (org-roam-capture-
         :keys "s"
         :node (org-roam-node-create :id (plist-get data :nodeid))
         :info (list :ref (plist-get data :ref)
                     :body (plist-get data :body)
                     :link (plist-get data :link)
                     :noteid (plist-get data :noteid)
                     :nodeid (plist-get data :nodeid))
         :templates org-roam-capture-templates))
      )
    nil)
#+end_src

**** 打开对应的 note org 文件
Note 文件一共分为 2 类：
1. 与 bibtex entry 对应的总笔记
2. 自己建立的各类分笔记

前者我们可以处理，后者仅通过 org-roam 处理。

打开的情况分为两种：
***** 在 skim 中仅打开文件，没有选中特定的 note
由 alfred 控制，通过 org-roam-ref-capture 创建/打开对应的 note 文件。 ref 为 citekey ，通过 pdf 首页的 note 获取。
#+begin_src emacs-lisp :tangle no
  ;; 该值在后续代码中有设置，此处无需 tangle
  (setq org-roam-capture-ref-templates
        '(("n" "single note" plain "%?"
           :target
           (file+head "ref/${ref}.org" "#+title: ${title}\n#+filetags: :Note:\n")
           :unnarrowed t
           :immediate-finish t
           :jump-to-captured t)))
#+end_src
***** 在 skim 中选中了某条特定的 note

通过读取 note 中设置的 org roam node id ，使用 emacsclient 直接打开。

**** 打开 note 对应的 pdf 位置

每条记录对应的位置，都是一个 org roam node ，会设置一个 SKIM_LINK 的 property ，该链接可以直接在 skim 中打开到对应的 pdf 及位置。

实现效果：跳转到笔记所在页面，并选中该笔记。
并未直接跳转到笔记的原因是，skim 默认跳转位置，会将笔记置于窗口的最上端，不符合需求；如果定制跳转规则，比较麻烦。

#+begin_src emacs-lisp
  (defun private/org-roam-get-property-at-point (key)
    (let* ((node (org-roam-node-at-point))
           (record (assoc key (org-roam-node-properties node))))
      (if record
          (cdr record)
        (error "no property found!"))))

  (defun private/org-roam-get-skim-note-info-at-point ()
    (let ((noteid (private/org-roam-get-property-at-point "SKIM_NOTE_ID"))
          (citekey (private/org-roam-get-property-at-point "ROAM_REFS"))
          )
      (list 'noteid noteid 'citekey citekey)))

  ;; add note action to orb
  (with-eval-after-load 'orb-note-actions
    (add-to-list 'orb-note-actions-user (cons "Open note in skim" 'private/open-note-in-skim)))

  (defun private/open-note-in-skim ()
    (interactive)
    (let ((citekey (private/org-roam-get-property-at-point "ROAM_REFS")))
      (private/open-note-in-skim citekey)))

  (defun private/open-note-in-skim (citekey)
    (let* ((noteid (private/org-roam-get-property-at-point "SKIM_NOTE_ID"))
           (key (car citekey))
           (attachment (orb-get-attached-file key)))
      (if attachment
          (funcall 'private/do-open-note-in-skim
                   (if orb-open-attached-file-as-truename
                       (file-truename attachment)
                     attachment)
                   noteid)
        (message "No PDF(s) found for this entry: %s" key))))

  (defun private/do-open-note-in-skim (filepath noteid)
    (if (string-equal (do-applescript
                       (concat
                        "tell application \"Skim\"\n"
                        "  set theDoc to (open \"" filepath "\")\n"
                        "  set theNotes to (every note of theDoc) whose id is \"" noteid "\"\n"
                        "  if (count theNotes) is 0 then\n"
                        "    return \"Error\"\n"
                        "  else\n"
                        "    set theNote to item 1 of theNotes\n"
                        "    go theDoc to page of theNote\n"
                        "    set (active note of theDoc) to theNote\n"
                        "    return \"Success\"\n"
                        "  end if\n"
                        "end tell\n"
                        )) "Success")
        (message "Success open the note.")
      (message "Error! No note.")))
#+end_src


#+begin_src emacs-lisp :tangle no
  (defun private/open-skim-link (uri)
    "Visit page of pdf in Skim"
    (let* ((note-id (when (string-match ";;\\(.+\\)\\'" uri) (match-string 1 uri)))
           (page (when (string-match "::\\(.+\\);;" uri) (match-string 1 uri)))
           (document (substring uri 0 (match-beginning 0))))
      (do-applescript
       (concat
        "tell application \"Skim\"\n"
        "activate\n"
        "set theDoc to open \"" document "\"\n"
        "set thePage to (first page of theDoc where its index =\"" page "\")\n"
        "try\n"
        "  set theNote to (first note of thePage where its id = \"" note-id "\")\n"
        "on error errMsg number errorNumber\n"
        "  set theNote to 0\n"
        "end try\n"
        "if theNote is 0 then\n"
        "    go document 1 to thePage\n"
        "else\n"
        "  set thePathList to (get path list of theNote)\n"
        "  set thePoint to (first item of (first list of thePathList))\n"
        "  go document 1 to thePage at thePoint\n"
        "  set active note to theNote\n"
        "end if\n"
        "end tell"))))

  (org-link-set-parameters "skim" :follow #'my-org-mac-skim-open)

  (defadvice org-capture-finalize
      (after org-capture-finalize-after activate)
    "Advise capture-finalize to close the frame"
    (if (equal "SA" (org-capture-get :key))
        (do-applescript "tell application \"Skim\"\n    activate\nend tell")))

  (defun private/clean-skim-page-link (link)
    (let* ((link (replace-regexp-in-string "\n" " " link))
           (link (replace-regexp-in-string "- " " " link)))
      link))

  (defun private/get-skim-page ()
    (let* ((page (do-applescript
                  (concat
                   "tell application \"Skim\"\n"
                   "set theDoc to front document\n"
                   "set thePage to (get index of current page of theDoc)\n"
                   "end tell\n"
                   "return thePage as integer\n"))))
      page))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (private/get-skim-page)


  (defun my-org-mac-skim-get-page ()
    (interactive)
    (message "Applescript: Getting Skim page link...")
    (org-mac-paste-applescript-links (my-as-clean-skim-page-link (my-as-get-skim-page-link))))

  (defun my-org-mac-skim-insert-page ()
    (interactive)
    (insert (my-org-mac-skim-get-page)))
  (defun my-org-move-point-to-capture ()
    (cond ((org-at-heading-p) (org-beginning-of-line))
          (t (org-previous-visible-heading 1))))

  (add-hook 'org-capture-prepare-finalize-hook #'(lambda () (private/skim-org-link (org-id-get-create))))

  (defun private/skim-org-link (id)
    (do-applescript (concat
                     "tell application \"Skim\"\n"
                     "set runstatus to \"not set\"\n"
                     "set theDoc to front document\n"
                     "try\n"
                     "    set theNote to active note of theDoc\n"
                     "end try\n"
                     "if theNote is not missing value then\n"
                     "    set newText to text of theNote\n"
                     "    set startpoint to  (offset of \"org-id:{\" in newtext)\n"
                     "    set endpoint to  (offset of \"}:org-id\" in newtext)\n"
                     "    if (startpoint is equal to endpoint) and (endpoint is equal to 0) then\n"
                     "        set newText to text of theNote & \"\norg-id:{\" & "
                     (applescript-quote-string id)
                     " & \"}:org-id\"\n"
                     "        set text of theNote to newText\n"
                     "        return \"set success\"\n"
                     "    end if\n"
                     "end if\n"
                     "end tell\n"
                     "return \"unset\"\n"
                     )))

  (defun applescript-quote-string (argument)
    "Quote a string for passing as a string to AppleScript."
    (if (or (not argument) (string-equal argument ""))
        "\"\""
      ;; Quote using double quotes, but escape any existing quotes or
      ;; backslashes in the argument with backslashes.
      (let ((result "")
            (start 0)
            end)
        (save-match-data
          (if (or (null (string-match "[^\"\\]" argument))
                  (< (match-end 0) (length argument)))
              (while (string-match "[\"\\]" argument start)
                (setq end (match-beginning 0)
                      result (concat result (substring argument start end)
                                     "\\" (substring argument end (1+ end)))
                      start (1+ end))))
          (concat "\"" result (substring argument start) "\"")))))
#+end_src
*** DONE 设置翻页快捷键
- State "DONE"       from "TODO"       [2021-11-14 Sun 21:55]
  检测当前是否有 nov buffer ，如果有，则执行 nov 翻页，否则执行 skim 翻页。

#+begin_src emacs-lisp
  ;;(add-to-list 'load-path "~/.emacs.d/helpers/")
  (require 'skim)

  (defun nov-buffer-in-current ()
    (cl-find-if
     (lambda (window)
       (with-current-buffer (window-buffer window) (eq major-mode 'nov-mode)))
     (window-list)))

  (defun reader/scroll-up (arg)
    (interactive "P")
    (let ((nov-window (nov-buffer-in-current))
          (current-window (get-buffer-window)))
      (if nov-window
          (progn
            (select-window nov-window)
            (nov-scroll-up arg)
            (select-window current-window))
        (skim-next-page))))

  (defun reader/scroll-down (arg)
    (interactive "P")
    (let ((nov-window (nov-buffer-in-current))
          (current-window (get-buffer-window)))
      (if nov-window
          (progn
            (select-window nov-window)
            (nov-scroll-down arg)
            (select-window current-window))
        (skim-prev-page))))

  (defun reader/goto-pdf-first-page-or-nov-toc ()
    (interactive)
    (let ((nov-window (nov-buffer-in-current))
          (current-window (get-buffer-window)))
      (if nov-window
          (progn
            (select-window nov-window)
            (nov-goto-toc)
            (select-window current-window))
        (skim-goto 1))))

#+end_src
** Helpers
*** tab 循环展开图片
#+begin_src emacs-lisp
  ;;; Only display inline images under current subtree.
  (defun org-display-subtree-inline-images (&optional state)
    "Toggle the display of inline images under current subtree.
  INCLUDE-LINKED is passed to `org-display-inline-images'."
    (interactive)
    (save-excursion
      (save-restriction
        (org-narrow-to-subtree)
        (let* ((beg (point-min))
               (end (point-max))
               (image-overlays (cl-intersection
                                org-inline-image-overlays
                                (overlays-in beg end)))
               (display-inline-images-local
                (lambda ()
                  (org-display-inline-images t t beg end)
                  (setq image-overlays (cl-intersection
                                        org-inline-image-overlays
                                        (overlays-in beg end)))
                  (if (and (org-called-interactively-p) image-overlays)
                      (message "%d images displayed inline"
                               (length image-overlays)))))
               (hide-inline-images-local
                (lambda ()
                  (org-remove-inline-images)
                  (message "Inline image display turned off"))))
          (if state
              (pcase state
                ('subtree
                 (funcall display-inline-images-local))
                ('folded
                 (funcall hide-inline-images-local)))
            (if image-overlays
                (funcall display-inline-images-local)
              (funcall hide-inline-images-local)))))))
#+end_src

*** 循环展开 properties
#+begin_src emacs-lisp
  (defun org-hide-properties ()
    "Hide all org-mode headline property drawers in buffer. Could be slow if it has a lot of overlays."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward
              "^ *:properties:\n\\( *:.+?:.*\n\\)+ *:end:\n" nil t)
        (let ((ov_this (make-overlay (match-beginning 0) (match-end 0))))
          (overlay-put ov_this 'display "")
          (overlay-put ov_this 'hidden-prop-drawer t))))
    (put 'org-toggle-properties-hide-state 'state 'hidden))

  (defun org-show-properties ()
    "Show all org-mode property drawers hidden by org-hide-properties."
    (interactive)
    (remove-overlays (point-min) (point-max) 'hidden-prop-drawer t)
    (put 'org-toggle-properties-hide-state 'state 'shown))

  (defun org-toggle-properties ()
    "Toggle visibility of property drawers."
    (interactive)
    (if (eq (get 'org-toggle-properties-hide-state 'state) 'hidden)
        (org-show-properties)
      (org-hide-properties)))
#+end_src

*** mac 通知
依赖于终端软件 =terminal-notifier= 。
#+begin_src emacs-lisp
  (defun notify-osx (title message)
    (call-process "terminal-notifier"
                  nil 0 nil
                  "-group" "Emacs"
                  "-title" title
                  "-sender" "org.gnu.Emacs"
                  "-mesage" message
                  "-activate" "org.gnu.Emacs"))
#+end_src
** Org-babel
#+begin_src emacs-lisp
  (use-package ob-elixir :after org)
  (use-package ox-gfm :after org)
  (use-package ob-applescript :after org)
  (use-package ob-racket
    :quelpa (ob-racket :fetcher github :repo "hasu/emacs-ob-racket" :branch "master")
    :init
    (setq ob-racket-default-lang "sicp")
    :after org)
  (use-package ob-mermaid :after org
    :config
    (setq ob-mermaid-cli-path "/opt/homebrew/bin/mmdc"))
#+end_src

** 美观
有时候反而觉得原始状态挺好看。。。而且这个插件极度影响性能。。。所以先禁止掉。
#+begin_src emacs-lisp
  (use-package org-modern
    :init
    (add-hook 'org-mode-hook 'global-org-modern-mode)
    :config
    (setq org-pretty-entities t
          org-ellipsis " ☇"
          org-hide-emphasis-markers t
          org-auto-align-tags nil
          org-tags-column 0
          org-insert-heading-respect-content t
          org-startup-folded t
          org-modern-star '("☯" "☰" "☱" "☲" "☳" "☴" "☵" "☶" "☷")
          ;; 保持缩进，默认为 hide-leading ，会将各级 heading 对齐，并不是期待的效果。
          ;; org-modern-hide-stars "  "
          org-modern-hide-stars 'leading
          org-modern-list
          '(;; (?- . "-")
            (?- . "•")
            (?* . "‣")))
    )
#+end_src

** Citar & Bibtex
#+begin_src emacs-lisp
  (use-package citar
    :config
    (defvar citar-indicator-files-icons
      (citar-indicator-create
       :symbol (nerd-icons-faicon
                "nf-fa-file_o"
                :face 'nerd-icons-green
                :v-adjust -0.1)
       :function #'citar-has-files
       :padding "  " ; need this because the default padding is too low for these icons
       :tag "has:files"))
    (defvar citar-indicator-links-icons
      (citar-indicator-create
       :symbol (nerd-icons-faicon
                "nf-fa-link"
                :face 'nerd-icons-orange
                :v-adjust 0.01)
       :function #'citar-has-links
       :padding "  "
       :tag "has:links"))
    (defvar citar-indicator-notes-icons
      (citar-indicator-create
       :symbol (nerd-icons-codicon
                "nf-cod-note"
                :face 'nerd-icons-blue
                :v-adjust -0.3)
       :function #'citar-has-notes
       :padding "    "
       :tag "has:notes"))
    (defvar citar-indicator-cited-icons
      (citar-indicator-create
       :symbol (nerd-icons-faicon
                "nf-fa-circle_o"
                :face 'nerd-icon-green)
       :function #'citar-is-cited
       :padding "  "
       :tag "is:cited"))
    (setq citar-bibliography `(,zotero-bib)
          org-cite-global-bibliography citar-bibliography
          org-cite-insert-processor 'citar
          org-cite-follow-processor 'citar
          org-cite-activate-processor 'citar
          citar-at-point-function 'embark-act
          citar-open-note-functions '(orb-citar-edit-note)
          citar-file-open-functions '((t . citar-file-open-external))
          citar-notes-paths `(,org-directory)
          citar-indicators (list citar-indicator-files-icons
                                 citar-indicator-links-icons
                                 citar-indicator-notes-icons
                                 citar-indicator-cited-icons))
    (defun private/open-in-zotero (citekey)
      "Open a reference item in Zotero."
      (interactive (list (citar-select-ref)))
      (citar-file-open-external
       (concat "zotero://select/items/@" citekey)))
    :general
    (general-define-key
     :keymaps 'minibuffer-local-map
     "M-b" 'citar-insert-preset))

  (use-package citar-embark
    :after (citar embark)
    :no-require
    :config (citar-embark-mode))

  (use-package citar-org-roam
    :after (citar org-roam)
    :config
    (citar-org-roam-mode)
    (setq citar-org-roam-note-title-template "${title}"
          citar-org-roam-capture-template-key "r")
    (citar-register-notes-source
     'orb-citar-source (list :name "Org-Roam Notes"
                             :category 'org-roam-node
                             :items #'citar-org-roam--get-candidates
                             :hasitems #'citar-org-roam-has-notes
                             :open #'citar-org-roam-open-note
                             :create #'orb-citar-edit-note
                             :annotate #'citar-org-roam--annotate))
    (setq citar-notes-source 'orb-citar-source))
#+end_src
** Org-roam
查阅相关资料后，对于我这种没有知识整理，文档输出的人废物来说，org-ref 没什么大作用。。。
计划使用 citar 和 skim 构建一个基于 pdf 文件的笔记系统。
#+begin_src emacs-lisp
  (require 'date-calc)

  (defun prefix-zero (number)
    (if (< number 10)
        (concat "0" (number-to-string number))
      (number-to-string number)))
  (defun first-day-of-this-week-str ()
    (let* ((first-day (date-calc-first-day-of-this-week))
           (month (nth 1 first-day))
           (day (nth 2 first-day)))
      (concat (prefix-zero month) "-" (prefix-zero day))))

  (first-day-of-this-week-str)
  (setq publication-bib (concat base-directory "publication_catelog.bib")
        zotero-bib (concat base-directory "zotero.bib")
        collections-bib (concat base-directory "collections.bib"))

  (use-package emacsql-sqlite-builtin)

  (use-package org-roam
    :init
    (add-hook 'after-init-hook 'org-roam-setup)
    (setq org-roam-v2-ack t
          org-roam-directory org-directory
          org-roam-db-gc-threshold most-positive-fixnum
          org-roam-db-location (concat org-directory "org-roam.db")
          org-roam-database-connector 'sqlite-builtin)

    (require 'org-roam-protocol)

    :config
    (push '("Skim note"
            :protocol "skimnote"
            :function skim-note-handler
            ) org-protocol-protocol-alist)
    ;; must after use-package org-roam
    (cl-defmethod org-roam-node-filetitle ((node org-roam-node))
      "Return the file TITLE for the node."
      (org-roam-get-keyword "TITLE" (org-roam-node-file node)))

    (cl-defmethod org-roam-node-hierarchy ((node org-roam-node))
      "Return the hierarchy for the node."
      (let ((title (org-roam-node-title node))
            (olp (org-roam-node-olp node))
            (level (org-roam-node-level node))
            (filetitle (org-roam-node-filetitle node)))
        (concat
         title
         (if (> level 0) (concat " | " filetitle))
         (if (> level 1) (concat " > " (string-join olp " > ")))
         )))

    (cl-defmethod org-roam-node-directories ((node org-roam-node))
      (if-let ((dirs (file-name-directory (file-relative-name (org-roam-node-file node) org-roam-directory))))
          (format "(%s)" (car (split-string dirs "/")))
        ""))

    (cl-defmethod org-roam-node-backlinkscount ((node org-roam-node))
      (let* ((count (caar (org-roam-db-query
                           [:select (funcall count source)
                                    :from links
                                    :where (= dest $s1)
                                    :and (= type "id")]
                           (org-roam-node-id node)))))
        (format "[%d]" count)))

    (setq org-roam-completion-everywhere t
          org-roam-node-display-template "${directories:10} ${tags:10} ${title:100} ${backlinkscount:6}"
          org-roam-capture-templates
          '(
            ("e" "immediate worklog" plain "** TODO ${title}\n:PROPERTIES:\n :ID: %(org-id-uuid)\n:END:\n"
             :target
             (file+olp "%(concat org-directory \"worklog.org\")" ("%<%Y>-W%<%W>/%(first-day-of-this-week-str)"))
             :unnarrowed t
             :immediate-finish t)
            ("w" "worklog" plain "** TODO ${title}\n:PROPERTIES:\n :ID: %(org-id-uuid)\n:END:\n %?"
             :target
             (file+olp "%(concat org-directory \"worklog.org\")" ("%<%Y>-W%<%W>/%(first-day-of-this-week-str)"))
             :unnarrowed t)
            ("f" "fleeting" plain "** TODO ${title}\n:PROPERTIES:\n :ID: %(org-id-uuid)\n:END:\n %?"
             :target
             (file+olp "%(concat org-directory \"fleeting.org\")" ("%<%Y>-W%<%W>/%(first-day-of-this-week-str)"))
             :unnarrowed t)
            ("n" "new node" plain "%?"
             :target
             (file+head "${slug}.org" "#+title: ${title}\n")
             :unnarrowed t
             :immediate-finish t)

            ("s" "fleeting skim note without quote" entry "* TODO ${noteid}\n:PROPERTIES:\n:ID: ${nodeid}\n:SKIM_LINK: ${link}\n:END:\n%?"
             :target
             ;;(file+olp "ref/${ref}.org" ("Fleeting"))
             (file "ref/${ref}.org")
             :unnarrowed t
             :immediate-finish t
             :jump-to-captured t
             :prepend t)
            ("q" "fleeting skim note" entry "* TODO ${noteid}\n:PROPERTIES:\n:ID: ${nodeid}\n:SKIM_LINK: ${link}\n:END:\n#+begin_quote\n${body}\n#+end_quote\n%?"
             :target
             ;;(file+olp "ref/${ref}.org" ("Fleeting"))
             (file "ref/${ref}.org")
             :unnarrowed t
             :immediate-finish t
             :jump-to-captured t
             :prepend t)
            ("r" "bibliography reference" plain "%?"
             :target
             (file+head "${citar-citekey}.org" "#+title: ${title}\n#+filetags: :Note:\n")
             :unnarrowed t))
          org-roam-capture-ref-templates '(
                                           ("n" "single note" plain "%?"
                                            :target
                                            (file+head "ref/${ref}.org" "#+title: ${title}\n#+filetags: :Note:\n")
                                            :unnarrowed t
                                            :immediate-finish t
                                            :jump-to-captured t
                                            ))
          )
    )

  (use-package org-roam-bibtex
    :hook (org-mode . org-roam-bibtex-mode)
    :after org-roam
    :init
    (setq orb-roam-ref-format 'org-cite)
    :config
    (setq orb-note-actions-interface 'hydra))

  (use-package bibtex-completion
    :init
    (setq bibtex-completion-bibliography `(,zotero-bib))
    :config
    (setq bibtex-completion-pdf-field "file"
          bibtex-completion-pdf-symbol "⌘"
          bibtex-completion-notes-symbol "✎"
          bibtex-completion-pdf-open-function (lambda (fpath)
                                                (call-process "open" nil 0 nil "-a" "/Applications/Skim.app" fpath))))

#+end_src
** Org-clock
#+begin_src emacs-lisp
  (setq org-clock-clocked-in-display nil
        org-clock-mode-line-total 'current)
#+end_src

** Org-pomodoro
番茄钟。但暂不使用。
#+begin_src emacs-lisp :tangle no
  (use-package org-pomodoro
    :commands org-pomodoro
    :config
    (add-hook 'org-pomodoro-finished-hook
              (lambda()
                (notify-osx "Pomodoro completed!" "Time for a break.")))
    (add-hook 'org-pomodoro-break-finished-hook
              (lambda()
                (notify-osx "Pomodoro Short Break Finished!" "Ready for Another?")))
    (add-hook 'org-pomodoro-long-break-finished-hook
              (lambda()
                (notify-osx "Pomodoro Long Break Finished!" "Ready for Another?")))
    (add-hook 'org-pomodoro-killed-hook
              (lambda()
                (notify-osx "Pomodoro Killed!" "One does not simply kill a pomodoro!"))))
#+end_src
** Org-download
#+begin_src emacs-lisp
  (use-package org-download
    :after org
    :config
    (setq org-download-method 'directory
          org-image-actual-width nil
          org-download-screenshot-method "screencapture -i %s"
          org-download-display-inline-images 'posframe
          ;; disable DOWNLOAD link
          org-download-annotate-function (lambda (_link) "")
          org-download-image-attr-list '("#+ATTR_HTML: :width 70% :align center"))
    (setq-default org-download-image-dir (concat org-directory "images/")))
#+end_src
** Toc-org
#+begin_src emacs-lisp
  (use-package toc-org
    :init
    (add-hook 'org-mode-hook 'toc-org-mode))
#+end_src
** ox-hugo
#+begin_src emacs-lisp
  (use-package ox-hugo
    :after ox
    :init
    (setq org-hugo-base-dir "~/Kenton/kenton.wang/")
    :config
    (defun insert-mermaid ()
      (interactive)
      (yas-expand "<mermaid"))
    )
#+end_src
** org-pandoc-import
#+begin_src emacs-lisp
  (use-package org-pandoc-import
    :quelpa (org-pandoc-import :fetcher github :repo "tecosaur/org-pandoc-import" :branch "master" :files ("*.el" "filters" "preprocessors")))
#+end_src
** Org-media-note
使用了自己本地的修改，修改的内容是可以获取继承的 property ，可以播放父级下的视频。
#+begin_src emacs-lisp
  (use-package org-media-note
    :hook (org-mode .  org-media-note-mode)
    :quelpa (org-media-note :fetcher github :repo "yuchen-lea/org-media-note" :branch "master")
    ;; :quelpa (org-media-note :fetcher file :path "~/Kenton/org-media-note")
    :init
    (setq org-media-note-use-org-ref nil
          org-media-note-ref-key-field "Video_ID")
    :config
    (setq org-media-note-screenshot-image-dir (concat org-directory "images/org-media/")
          org-media-note-use-refcite-first t))
#+end_src

** 翻译
注意， =sdcv-dictionary-data-dir= 必须使用绝对地址。
#+begin_src emacs-lisp
  (use-package sdcv
    :quelpa (sdcv :fetcher github :repo "manateelazycat/sdcv" :branch "master")
    :init
    (setq sdcv-dictionary-data-dir (file-truename (concat  private/config-directory "dictionary/"))
          sdcv-program "/opt/homebrew/bin/sdcv")
    :config
    (setq sdcv-dictionary-simple-list '("21世纪英汉汉英双向词典")
          sdcv-dictionary-complete-list '("21世纪英汉汉英双向词典"))
    (defun private/say-word-at-point ()
      (interactive)
      (sdcv-say-word (sdcv-region-or-word)))
    :general
    (general-define-key
     "s-E" 'sdcv-search-pointer+)
    (common-leader
      "k" '(:igonre :whick-key "sdcv")
      "ks" 'private/say-word-at-point
      "kk" 'sdcv-search-pointer+
      "kf" 'sdcv-search-pointer))
#+end_src

#+RESULTS:

** KeyBindings
整体规划 org-mode 的按键。涉及到默认按键更改、全局按键、org-mode 按键。
#+begin_src emacs-lisp
  (defun private/org-roam-node-find-with-choiceform-filter ()
  (interactive)
  (let ((tag "choiceform"))
    (org-roam-node-find nil nil
                        (lambda (node)
                          (member tag
                                  (org-roam-node-tags node))))))

  (defun private/org-roam-node-find-without-choiceform-filter ()
  (interactive)
  (let ((tag "choiceform"))
    (org-roam-node-find nil nil
                        (lambda (node)
                          (not (member tag
                                  (org-roam-node-tags node)))))))

  (general-define-key
   :keymaps 'org-mode-map
   "C-c C-r" nil
   "C-c r" 'org-reveal
   "C-s-4" 'org-download-screenshot
   "H-v" 'org-media-note-hydra/body
   "C-c ]" 'citar-insert-citation)

  (common-leader
    "r" '(:ignore t :which-key "org-roam")
    "rf" 'private/org-roam-node-find-without-choiceform-filter
    "wf" 'private/org-roam-node-find-with-choiceform-filter
    "rr" 'citar-open)

  (local-leader
    :keymaps 'org-mode-map
    "i" '(:ignore t :which-key "insert")
    "ii" 'org-roam-node-insert
    "ia" 'org-roam-alias-add
    "ir" 'org-roam-ref-add
    "it" 'org-roam-tag-add
    "l" '(:ignore t :which-key "link")
    ;; "lr" 'org-mac-skim-insert-page ;; skim
    ;; "ls"  'org-mac-safari-insert-frontmost-url ;; internet
    ;; "lf"  'org-mac-finder-insert-selected ;; finder
    "ll" 'org-store-link
    "li" 'org-insert-last-stored-link)

  (general-define-key
   :keymaps 'org-mode-map
   "M-o" 'reader/goto-pdf-first-page-or-nov-toc
   "M-n" 'reader/scroll-up
   "M-p" 'reader/scroll-down)

  (general-define-key
   :keymaps 'nov-mode-map
   "M-n" 'nov-scroll-up
   "M-p" 'nov-scroll-down)

  (general-define-key
   :keymaps 'org-mode-map
   :prefix "C-c C-r"
   "r" 'org-roam-buffer-toggle
   "C-i" 'org-roam-node-insert
   "g" 'org-roam-graph
   "i" '(:ignore t :which-key "add property")
   "i a" 'org-roam-alias-add
   "i r" 'org-roam-ref-add
   "i t" 'org-roam-tag-add
   "d" '(:ignore t :which-key "remove property")
   "d a" 'org-roam-alias-remove
   "d r" 'org-roam-ref-remove
   "d t" 'org-roam-tag-remove)

  (general-define-key
   :keymaps 'org-roam-mode-map
   [mouse-1] 'org-roam-visit-thing)
#+end_src

** pdf-tools

install =epdfinfo= server by run =pdf-tools-install .=

#+begin_src emacs-lisp
  (use-package pdf-tools
    :config
    (setq pdf-view-selection-style 'glyph
          pdf-view-use-imagemagick t)
    (pdf-tools-install)
    )

  (use-package org-pdftools
    :hook (org-mode . org-pdftools-setup-link))

  (use-package org-noter
    :config
    ;; Your org-noter config ........
    (require 'org-noter-pdftools))

  (use-package org-noter-pdftools
    :after org-noter
    :config
    ;; Add a function to ensure precise note is inserted
    (defun org-noter-pdftools-insert-precise-note (&optional toggle-no-questions)
      (interactive "P")
      (org-noter--with-valid-session
       (let ((org-noter-insert-note-no-questions (if toggle-no-questions
                                                     (not org-noter-insert-note-no-questions)
                                                   org-noter-insert-note-no-questions))
             (org-pdftools-use-isearch-link t)
             (org-pdftools-use-freepointer-annot t))
         (org-noter-insert-note (org-noter--get-precise-info)))))

    ;; fix https://github.com/weirdNox/org-noter/pull/93/commits/f8349ae7575e599f375de1be6be2d0d5de4e6cbf
    (defun org-noter-set-start-location (&optional arg)
      "When opening a session with this document, go to the current location.
      With a prefix ARG, remove start location."
      (interactive "P")
      (org-noter--with-valid-session
       (let ((inhibit-read-only t)
             (ast (org-noter--parse-root))
             (location (org-noter--doc-approx-location (when (called-interactively-p 'any) 'interactive))))
         (with-current-buffer (org-noter--session-notes-buffer session)
           (org-with-wide-buffer
            (goto-char (org-element-property :begin ast))
            (if arg
                (org-entry-delete nil org-noter-property-note-location)
              (org-entry-put nil org-noter-property-note-location
                             (org-noter--pretty-print-location location))))))))
    (with-eval-after-load 'pdf-annot
      (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+end_src
